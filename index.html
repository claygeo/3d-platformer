<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced 3D Platformer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        /* Loading Screen */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .loading-content {
            text-align: center;
            color: white;
        }

        .loading-content h1 {
            font-size: 3rem;
            margin-bottom: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .loading-bar {
            width: 300px;
            height: 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .loading-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            border-radius: 10px;
            transition: width 0.3s ease;
            width: 0%;
        }

        /* Game UI */
        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        #topUI {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px 20px;
            border-radius: 10px;
            color: white;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }

        .ui-panel {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .label {
            font-weight: bold;
            color: #FFD700;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }

        .control-group h3 {
            margin-bottom: 10px;
            color: #4CAF50;
        }

        .control {
            margin: 5px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .key {
            background: #333;
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
        }

        /* Camera Controls Info */
        #cameraInfo {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }

        /* Game Messages */
        #gameMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            backdrop-filter: blur(15px);
            pointer-events: auto;
            z-index: 200;
        }

        #gameMessage.hidden {
            display: none;
        }

        #gameMessage h2 {
            margin-bottom: 15px;
            color: #4CAF50;
        }

        #gameMessage button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
            font-size: 16px;
            transition: background 0.3s;
        }

        #gameMessage button:hover {
            background: #45a049;
        }

        /* Pause Menu */
        #pauseMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            backdrop-filter: blur(15px);
            pointer-events: auto;
            z-index: 200;
        }

        #pauseMenu.hidden {
            display: none;
        }

        #pauseMenu h2 {
            margin-bottom: 20px;
            color: #4CAF50;
        }

        #pauseMenu button {
            display: block;
            width: 100%;
            background: #333;
            color: white;
            border: none;
            padding: 12px;
            margin: 10px 0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
        }

        #pauseMenu button:hover {
            background: #4CAF50;
        }

        .fade-in {
            animation: fadeIn 1s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Camera Mode Indicator */
        #cameraMode {
            position: absolute;
            bottom: 80px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 8px;
            color: white;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }

        .mode-active {
            color: #4CAF50;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Loading Screen -->
        <div id="loading">
            <div class="loading-content">
                <h1>Enhanced 3D Platformer</h1>
                <div class="loading-text">Loading Enhanced Assets...</div>
                <div class="loading-bar">
                    <div class="loading-fill" id="loadingFill"></div>
                </div>
                <div id="loadingPercent">0%</div>
            </div>
        </div>

        <!-- Main Game UI -->
        <div id="gameUI" style="display: none;">
            <div id="topUI">
                <div class="ui-panel">
                    <div class="stat">
                        <span class="label">Score:</span>
                        <span id="score">0</span>
                    </div>
                    <div class="stat">
                        <span class="label">Lives:</span>
                        <span id="lives">3</span>
                    </div>
                    <div class="stat">
                        <span class="label">Coins:</span>
                        <span id="coins">0</span>/<span id="totalCoins">0</span>
                    </div>
                    <div class="stat">
                        <span class="label">Level:</span>
                        <span id="currentLevel">1</span>
                    </div>
                </div>
            </div>

            <div id="cameraInfo">
                <div class="control-group">
                    <h3>Enhanced Camera</h3>
                    <div class="control"><span class="key">Mouse Drag</span> Orbit Camera</div>
                    <div class="control"><span class="key">Scroll Wheel</span> Zoom</div>
                    <div class="control"><span class="key">C</span> Toggle Camera Mode</div>
                    <div class="control"><span class="key">F</span> Focus Player</div>
                </div>
            </div>

            <div id="instructions">
                <div class="control-group">
                    <h3>Controls</h3>
                    <div class="control"><span class="key">WASD</span> Move</div>
                    <div class="control"><span class="key">Space</span> Jump</div>
                    <div class="control"><span class="key">Shift</span> Run</div>
                    <div class="control"><span class="key">R</span> Restart Level</div>
                    <div class="control"><span class="key">N</span> Next Level</div>
                    <div class="control"><span class="key">ESC</span> Pause</div>
                </div>
            </div>

            <div id="cameraMode">
                Camera Mode: <span id="cameraModeText" class="mode-active">Free Orbit</span>
            </div>

            <!-- Game Messages -->
            <div id="gameMessage" class="hidden">
                <div class="message-content">
                    <h2 id="messageTitle">Level Complete!</h2>
                    <p id="messageText">Great job! Moving to next level...</p>
                    <button id="messageButton" onclick="game.hideMessage()">Continue</button>
                </div>
            </div>
        </div>

        <!-- Pause Menu -->
        <div id="pauseMenu" class="hidden">
            <div class="menu-content">
                <h2>Game Paused</h2>
                <button onclick="game.resumeGame()">Resume</button>
                <button onclick="game.restartLevel()">Restart Level</button>
                <button onclick="game.loadLevel(1)">Back to Level 1</button>
            </div>
        </div>
    </div>

    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // Enhanced Utility Functions
        const Utils = {
            loadedModels: {},
            
            loadModel(path, loader) {
                return new Promise((resolve, reject) => {
                    // For demo purposes, we'll create fallback geometries
                    const fallback = this.createFallbackFromPath(path);
                    this.loadedModels[path] = fallback;
                    resolve(fallback);
                });
            },

            createFallbackFromPath(path) {
                const filename = path.split('/').pop().replace('.glb', '');
                let geometry, material, mesh;

                // Platform types
                if (filename.includes('grass')) {
                    geometry = new THREE.BoxGeometry(2, 1, 2);
                    material = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
                } else if (filename.includes('platform')) {
                    geometry = new THREE.BoxGeometry(2, 0.5, 2);
                    material = new THREE.MeshLambertMaterial({ color: 0x9E9E9E });
                }
                // Collectibles
                else if (filename.includes('coin')) {
                    geometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 12);
                    material = new THREE.MeshLambertMaterial({ 
                        color: filename.includes('gold') ? 0xFFD700 : 
                               filename.includes('silver') ? 0xC0C0C0 : 0xCD7F32 
                    });
                } else if (filename.includes('heart')) {
                    geometry = new THREE.SphereGeometry(0.3, 8, 8);
                    material = new THREE.MeshLambertMaterial({ color: 0xFF69B4 });
                } else if (filename.includes('jewel')) {
                    geometry = new THREE.OctahedronGeometry(0.4);
                    material = new THREE.MeshLambertMaterial({ color: 0x9C27B0 });
                } else if (filename.includes('key')) {
                    geometry = new THREE.BoxGeometry(0.2, 0.6, 0.1);
                    material = new THREE.MeshLambertMaterial({ color: 0xFFC107 });
                }
                // Environment
                else if (filename.includes('tree')) {
                    geometry = new THREE.CylinderGeometry(0.3, 0.5, 3, 8);
                    material = new THREE.MeshLambertMaterial({ color: 0x2E7D32 });
                } else if (filename.includes('rocks')) {
                    geometry = new THREE.SphereGeometry(0.8, 6, 6);
                    material = new THREE.MeshLambertMaterial({ color: 0x5D4037 });
                } else if (filename.includes('flowers')) {
                    geometry = new THREE.SphereGeometry(0.2, 8, 8);
                    material = new THREE.MeshLambertMaterial({ color: 0xE91E63 });
                }
                // Interactive
                else if (filename.includes('crate')) {
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x8D6E63 });
                } else if (filename.includes('chest')) {
                    geometry = new THREE.BoxGeometry(1, 0.8, 0.6);
                    material = new THREE.MeshLambertMaterial({ color: 0x6D4C41 });
                } else if (filename.includes('flag')) {
                    const group = new THREE.Group();
                    const pole = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.05, 0.05, 3),
                        new THREE.MeshLambertMaterial({ color: 0x8D6E63 })
                    );
                    const flag = new THREE.Mesh(
                        new THREE.PlaneGeometry(1, 0.6),
                        new THREE.MeshLambertMaterial({ color: 0xFF4444 })
                    );
                    flag.position.set(0.5, 1, 0);
                    group.add(pole);
                    group.add(flag);
                    group.castShadow = true;
                    group.receiveShadow = true;
                    return group;
                }
                // Hazards
                else if (filename.includes('spike')) {
                    geometry = new THREE.ConeGeometry(0.5, 1, 4);
                    material = new THREE.MeshLambertMaterial({ color: 0xFF5722 });
                } else if (filename.includes('saw')) {
                    geometry = new THREE.CylinderGeometry(0.8, 0.8, 0.1, 12);
                    material = new THREE.MeshLambertMaterial({ color: 0xF44336 });
                }
                // Default
                else {
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x808080 });
                }

                mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            },

            cloneModel(path) {
                if (!this.loadedModels[path]) return null;
                return this.loadedModels[path].clone();
            },

            distance(pos1, pos2) {
                return pos1.distanceTo(pos2);
            },

            isColliding(obj1, obj2, threshold = 2) {
                return this.distance(obj1.position, obj2.position) < threshold;
            },

            isOnPlatform(player, platform, threshold = 3) {
                const horizontalDistance = Math.sqrt(
                    Math.pow(player.position.x - platform.position.x, 2) +
                    Math.pow(player.position.z - platform.position.z, 2)
                );
                const verticalDistance = player.position.y - platform.position.y;
                return horizontalDistance < threshold && verticalDistance > 0.5 && verticalDistance < 3;
            },

            lerp(start, end, factor) {
                return start + (end - start) * factor;
            },

            clamp(value, min, max) {
                return Math.max(min, Math.min(max, value));
            },

            degToRad(degrees) {
                return degrees * (Math.PI / 180);
            },

            animateFloat(object, speed = 0.005, amplitude = 0.3) {
                const time = Date.now() * speed;
                const originalY = object.userData.originalY || object.position.y;
                object.userData.originalY = originalY;
                object.position.y = originalY + Math.sin(time) * amplitude;
            },

            animateRotate(object, speedX = 0, speedY = 0.02, speedZ = 0) {
                object.rotation.x += speedX;
                object.rotation.y += speedY;
                object.rotation.z += speedZ;
            },

            updateUI(id, value) {
                const element = document.getElementById(id);
                if (element) element.textContent = value;
            },

            showMessage(title, text, buttonText = 'Continue', callback = null) {
                const messageDiv = document.getElementById('gameMessage');
                const titleElement = document.getElementById('messageTitle');
                const textElement = document.getElementById('messageText');
                const buttonElement = document.getElementById('messageButton');

                titleElement.textContent = title;
                textElement.textContent = text;
                buttonElement.textContent = buttonText;
                
                if (callback) buttonElement.onclick = callback;
                messageDiv.classList.remove('hidden');
            },

            hideMessage() {
                document.getElementById('gameMessage').classList.add('hidden');
            },

            togglePauseMenu(show) {
                const pauseMenu = document.getElementById('pauseMenu');
                if (show) {
                    pauseMenu.classList.remove('hidden');
                } else {
                    pauseMenu.classList.add('hidden');
                }
            },

            updateLoadingProgress(progress) {
                const fillElement = document.getElementById('loadingFill');
                const percentElement = document.getElementById('loadingPercent');
                
                if (fillElement) fillElement.style.width = progress + '%';
                if (percentElement) percentElement.textContent = Math.round(progress) + '%';
            },

            showGameUI() {
                const loadingDiv = document.getElementById('loading');
                const gameUI = document.getElementById('gameUI');
                
                if (loadingDiv) loadingDiv.style.display = 'none';
                if (gameUI) {
                    gameUI.style.display = 'block';
                    gameUI.classList.add('fade-in');
                }
            },

            createParticleEffect(scene, position, color = 0xFFD700) {
                const particles = [];
                const particleCount = 10;
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05, 8, 8),
                        new THREE.MeshBasicMaterial({ color })
                    );
                    
                    particle.position.copy(position);
                    particle.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2,
                        Math.random() * 0.2,
                        (Math.random() - 0.5) * 0.2
                    );
                    particle.life = 1.0;
                    
                    particles.push(particle);
                    scene.add(particle);
                }
                
                const animateParticles = () => {
                    particles.forEach((particle, index) => {
                        particle.position.add(particle.velocity);
                        particle.velocity.y -= 0.01;
                        particle.life -= 0.02;
                        particle.material.opacity = particle.life;
                        
                        if (particle.life <= 0) {
                            scene.remove(particle);
                            particles.splice(index, 1);
                        }
                    });
                    
                    if (particles.length > 0) {
                        requestAnimationFrame(animateParticles);
                    }
                };
                
                animateParticles();
            }
        };

        // Enhanced Camera Controls
        class CameraController {
            constructor(camera, player) {
                this.camera = camera;
                this.player = player;
                
                // Camera modes
                this.modes = {
                    FREE_ORBIT: 'Free Orbit',
                    FOLLOW: 'Follow',
                    FIXED: 'Fixed'
                };
                this.currentMode = this.modes.FREE_ORBIT;
                
                // Orbit controls
                this.distance = 15;
                this.minDistance = 5;
                this.maxDistance = 50;
                this.azimuth = 0; // Horizontal rotation
                this.elevation = 0.3; // Vertical rotation
                this.minElevation = -Math.PI / 3;
                this.maxElevation = Math.PI / 3;
                
                // Mouse state
                this.isMouseDown = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                
                // Smooth movement
                this.targetPosition = new THREE.Vector3();
                this.targetLookAt = new THREE.Vector3();
                
                this.setupControls();
            }
            
            setupControls() {
                const canvas = document.querySelector('canvas');
                
                // Mouse controls
                canvas.addEventListener('mousedown', (event) => {
                    this.isMouseDown = true;
                    this.lastMouseX = event.clientX;
                    this.lastMouseY = event.clientY;
                });
                
                canvas.addEventListener('mousemove', (event) => {
                    if (!this.isMouseDown || this.currentMode !== this.modes.FREE_ORBIT) return;
                    
                    const deltaX = event.clientX - this.lastMouseX;
                    const deltaY = event.clientY - this.lastMouseY;
                    
                    this.azimuth -= deltaX * 0.01;
                    this.elevation = Utils.clamp(
                        this.elevation - deltaY * 0.01,
                        this.minElevation,
                        this.maxElevation
                    );
                    
                    this.lastMouseX = event.clientX;
                    this.lastMouseY = event.clientY;
                });
                
                canvas.addEventListener('mouseup', () => {
                    this.isMouseDown = false;
                });
                
                // Wheel zoom
                canvas.addEventListener('wheel', (event) => {
                    event.preventDefault();
                    if (this.currentMode !== this.modes.FREE_ORBIT) return;
                    
                    this.distance = Utils.clamp(
                        this.distance + event.deltaY * 0.01,
                        this.minDistance,
                        this.maxDistance
                    );
                });
                
                // Keyboard controls
                document.addEventListener('keydown', (event) => {
                    switch(event.code) {
                        case 'KeyC':
                            this.toggleMode();
                            break;
                        case 'KeyF':
                            this.focusPlayer();
                            break;
                    }
                });
            }
            
            toggleMode() {
                const modes = Object.values(this.modes);
                const currentIndex = modes.indexOf(this.currentMode);
                const nextIndex = (currentIndex + 1) % modes.length;
                this.currentMode = modes[nextIndex];
                
                document.getElementById('cameraModeText').textContent = this.currentMode;
                
                if (this.currentMode === this.modes.FOLLOW) {
                    this.focusPlayer();
                }
            }
            
            focusPlayer() {
                // Smoothly move camera to focus on player
                this.azimuth = 0;
                this.elevation = 0.3;
                this.distance = 15;
            }
            
            update() {
                const playerPos = this.player.position;
                
                switch(this.currentMode) {
                    case this.modes.FREE_ORBIT:
                        this.updateOrbitCamera(playerPos);
                        break;
                    case this.modes.FOLLOW:
                        this.updateFollowCamera(playerPos);
                        break;
                    case this.modes.FIXED:
                        this.updateFixedCamera(playerPos);
                        break;
                }
            }
            
            updateOrbitCamera(playerPos) {
                // Calculate camera position in spherical coordinates
                const x = playerPos.x + this.distance * Math.cos(this.elevation) * Math.sin(this.azimuth);
                const y = playerPos.y + this.distance * Math.sin(this.elevation) + 5;
                const z = playerPos.z + this.distance * Math.cos(this.elevation) * Math.cos(this.azimuth);
                
                this.targetPosition.set(x, y, z);
                this.targetLookAt.copy(playerPos).add(new THREE.Vector3(0, 1, 0));
                
                // Smooth camera movement
                this.camera.position.lerp(this.targetPosition, 0.1);
                
                // Look at player
                const lookAtPos = this.targetLookAt.clone();
                this.camera.lookAt(lookAtPos);
            }
            
            updateFollowCamera(playerPos) {
                // Traditional follow camera with slight orbit influence
                const idealPos = new THREE.Vector3(
                    playerPos.x + Math.sin(this.azimuth) * 10,
                    playerPos.y + 8,
                    playerPos.z + Math.cos(this.azimuth) * 10
                );
                
                this.camera.position.lerp(idealPos, 0.05);
                
                const lookAtPos = new THREE.Vector3(
                    playerPos.x + this.player.velocity.x * 2,
                    playerPos.y + 1,
                    playerPos.z + this.player.velocity.z * 2
                );
                
                this.camera.lookAt(lookAtPos);
            }
            
            updateFixedCamera(playerPos) {
                // Fixed camera position with smooth look-at
                const fixedPos = new THREE.Vector3(playerPos.x, playerPos.y + 15, playerPos.z + 20);
                this.camera.position.lerp(fixedPos, 0.02);
                this.camera.lookAt(playerPos);
            }
        }

        // Enhanced Player class
        class Player {
            constructor(scene) {
                this.scene = scene;
                this.mesh = null;
                
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.position = new THREE.Vector3(0, 5, 0);
                this.rotation = 0;
                
                this.speed = 0.15;
                this.jumpForce = 0.4;
                this.gravity = -0.02;
                
                this.isGrounded = false;
                this.isJumping = false;
                this.lives = 3;
                this.isAlive = true;
                
                this.keys = {
                    left: false, right: false, forward: false, backward: false,
                    space: false, shift: false
                };
                
                this.init();
                this.setupInput();
            }
            
            init() {
                const geometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
                const material = new THREE.MeshLambertMaterial({ 
                    color: 0x4CAF50,
                    transparent: true,
                    opacity: 0.9
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                
                const faceGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const faceMaterial = new THREE.MeshBasicMaterial({ color: 0x2196F3 });
                this.face = new THREE.Mesh(faceGeometry, faceMaterial);
                this.face.position.set(0, 0.3, 0.4);
                this.mesh.add(this.face);
                
                this.scene.add(this.mesh);
            }
            
            setupInput() {
                document.addEventListener('keydown', (event) => this.handleKeyDown(event));
                document.addEventListener('keyup', (event) => this.handleKeyUp(event));
            }
            
            handleKeyDown(event) {
                switch(event.code) {
                    case 'KeyW': case 'ArrowUp': this.keys.forward = true; break;
                    case 'KeyS': case 'ArrowDown': this.keys.backward = true; break;
                    case 'KeyA': case 'ArrowLeft': this.keys.left = true; break;
                    case 'KeyD': case 'ArrowRight': this.keys.right = true; break;
                    case 'Space': this.keys.space = true; event.preventDefault(); break;
                    case 'ShiftLeft': case 'ShiftRight': this.keys.shift = true; break;
                }
            }
            
            handleKeyUp(event) {
                switch(event.code) {
                    case 'KeyW': case 'ArrowUp': this.keys.forward = false; break;
                    case 'KeyS': case 'ArrowDown': this.keys.backward = false; break;
                    case 'KeyA': case 'ArrowLeft': this.keys.left = false; break;
                    case 'KeyD': case 'ArrowRight': this.keys.right = false; break;
                    case 'Space': this.keys.space = false; break;
                    case 'ShiftLeft': case 'ShiftRight': this.keys.shift = false; break;
                }
            }
            
            update(platforms = [], collectibles = [], hazards = []) {
                if (!this.isAlive) return;
                
                this.updateMovement();
                this.updatePhysics();
                this.checkPlatformCollisions(platforms);
                this.checkCollectibleCollisions(collectibles);
                this.checkHazardCollisions(hazards);
                this.checkBoundaries();
                this.updateMesh();
            }
            
            updateMovement() {
                const currentSpeed = this.keys.shift ? this.speed * 1.5 : this.speed;
                
                if (this.keys.left) {
                    this.velocity.x = -currentSpeed;
                } else if (this.keys.right) {
                    this.velocity.x = currentSpeed;
                } else {
                    this.velocity.x *= 0.8;
                }
                
                if (this.keys.forward) {
                    this.velocity.z = -currentSpeed;
                } else if (this.keys.backward) {
                    this.velocity.z = currentSpeed;
                } else {
                    this.velocity.z *= 0.8;
                }
                
                if (this.keys.space && this.isGrounded && !this.isJumping) {
                    this.velocity.y = this.jumpForce;
                    this.isGrounded = false;
                    this.isJumping = true;
                }
                
                const maxSpeed = currentSpeed * 1.2;
                this.velocity.x = Utils.clamp(this.velocity.x, -maxSpeed, maxSpeed);
                this.velocity.z = Utils.clamp(this.velocity.z, -maxSpeed, maxSpeed);
            }
            
            updatePhysics() {
                if (!this.isGrounded) {
                    this.velocity.y += this.gravity;
                }
                
                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;
                this.position.z += this.velocity.z;
                
                if (this.position.y <= 1) {
                    this.position.y = 1;
                    this.velocity.y = 0;
                    this.isGrounded = true;
                    this.isJumping = false;
                }
            }
            
            checkPlatformCollisions(platforms) {
                let onPlatform = false;
                
                platforms.forEach(platform => {
                    if (Utils.isOnPlatform(this, platform)) {
                        if (this.velocity.y <= 0) {
                            this.position.y = platform.position.y + 2;
                            this.velocity.y = 0;
                            this.isGrounded = true;
                            this.isJumping = false;
                            onPlatform = true;
                        }
                    }
                });
                
                if (!onPlatform && this.position.y > 1.1) {
                    this.isGrounded = false;
                }
            }
            
            checkCollectibleCollisions(collectibles) {
                collectibles.forEach(collectible => {
                    if (!collectible.userData.collected && Utils.isColliding(this, collectible, 1.5)) {
                        this.collectItem(collectible);
                    }
                });
            }
            
            checkHazardCollisions(hazards) {
                hazards.forEach(hazard => {
                    if (Utils.isColliding(this, hazard, 1.5)) {
                        this.takeDamage();
                    }
                });
            }
            
            collectItem(collectible) {
                collectible.userData.collected = true;
                collectible.visible = false;
                
                Utils.createParticleEffect(this.scene, collectible.position.clone(), 0xFFD700);
                
                const type = collectible.userData.type || 'coin';
                
                switch(type) {
                    case 'coin-gold':
                        game.addScore(100);
                        game.addCoin();
                        break;
                    case 'coin-silver':
                        game.addScore(50);
                        game.addCoin();
                        break;
                    case 'coin-bronze':
                        game.addScore(25);
                        game.addCoin();
                        break;
                    case 'heart':
                        this.addLife();
                        game.addScore(200);
                        break;
                    case 'jewel':
                        game.addScore(500);
                        break;
                    case 'key':
                        game.addScore(300);
                        break;
                    default:
                        game.addScore(50);
                        game.addCoin();
                        break;
                }
            }
            
            takeDamage() {
                if (!this.isAlive) return;
                
                this.lives--;
                Utils.updateUI('lives', this.lives);
                
                Utils.createParticleEffect(this.scene, this.position.clone(), 0xFF0000);
                
                this.velocity.y = 0.2;
                this.velocity.x *= -2;
                this.velocity.z *= -2;
                
                if (this.lives <= 0) {
                    this.die();
                } else {
                    this.mesh.material.color.setHex(0xFF0000);
                    setTimeout(() => {
                        this.mesh.material.color.setHex(0x4CAF50);
                    }, 500);
                }
            }
            
            addLife() {
                this.lives++;
                Utils.updateUI('lives', this.lives);
            }
            
            die() {
                this.isAlive = false;
                this.mesh.material.color.setHex(0x666666);
                this.mesh.material.opacity = 0.5;
                
                setTimeout(() => {
                    game.playerDied();
                }, 1000);
            }
            
            checkBoundaries() {
                if (this.position.y < -20) {
                    this.takeDamage();
                    this.respawn();
                }
                
                const maxDistance = 100;
                this.position.x = Utils.clamp(this.position.x, -maxDistance, maxDistance);
                this.position.z = Utils.clamp(this.position.z, -maxDistance, maxDistance);
            }
            
            respawn() {
                this.position.set(0, 5, 0);
                this.velocity.set(0, 0, 0);
                this.isGrounded = false;
                this.isJumping = false;
            }
            
            updateMesh() {
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    
                    if (Math.abs(this.velocity.x) > 0.01 || Math.abs(this.velocity.z) > 0.01) {
                        const angle = Math.atan2(this.velocity.x, this.velocity.z);
                        this.mesh.rotation.y = Utils.lerp(this.mesh.rotation.y, angle, 0.1);
                    }
                    
                    if (this.isGrounded && (Math.abs(this.velocity.x) > 0.01 || Math.abs(this.velocity.z) > 0.01)) {
                        this.mesh.position.y += Math.sin(Date.now() * 0.01) * 0.05;
                    }
                }
            }
            
            reset(spawnPosition = new THREE.Vector3(0, 5, 0)) {
                this.position.copy(spawnPosition);
                this.velocity.set(0, 0, 0);
                this.isGrounded = false;
                this.isJumping = false;
                this.isAlive = true;
                
                if (this.mesh) {
                    this.mesh.material.color.setHex(0x4CAF50);
                    this.mesh.material.opacity = 0.9;
                    this.mesh.position.copy(this.position);
                }
            }
        }

        // Enhanced Level class with 3D spatial design
        class Level {
            constructor(scene, gltfLoader) {
                this.scene = scene;
                this.gltfLoader = gltfLoader;
                
                this.platforms = [];
                this.collectibles = [];
                this.hazards = [];
                this.environment = [];
                this.interactive = [];
                this.movingPlatforms = [];
                
                this.currentLevel = 1;
                this.totalCoins = 0;
                
                this.assetPaths = {
                    platforms: {
                        'grass': 'assets/models/platforms/block-grass.glb',
                        'grass-large': 'assets/models/platforms/block-grass-large.glb',
                        'grass-corner': 'assets/models/platforms/block-grass-corner.glb',
                        'grass-curve': 'assets/models/platforms/block-grass-curve.glb',
                        'platform': 'assets/models/platforms/platform.glb',
                        'platform-ramp': 'assets/models/platforms/platform-ramp.glb'
                    },
                    collectibles: {
                        'coin-gold': 'assets/models/collectibles/coin-gold.glb',
                        'coin-silver': 'assets/models/collectibles/coin-silver.glb',
                        'coin-bronze': 'assets/models/collectibles/coin-bronze.glb',
                        'heart': 'assets/models/collectibles/heart.glb',
                        'jewel': 'assets/models/collectibles/jewel.glb',
                        'key': 'assets/models/collectibles/key.glb'
                    },
                    environment: {
                        'tree': 'assets/models/environment/tree.glb',
                        'tree-pine': 'assets/models/environment/tree-pine.glb',
                        'rocks': 'assets/models/environment/rocks.glb',
                        'grass': 'assets/models/environment/grass.glb',
                        'flowers': 'assets/models/environment/flowers.glb'
                    },
                    interactive: {
                        'crate': 'assets/models/interactive/crate.glb',
                        'chest': 'assets/models/interactive/chest.glb',
                        'button': 'assets/models/interactive/button-round.glb',
                        'flag': 'assets/models/interactive/flag.glb'
                    },
                    hazards: {
                        'spike': 'assets/models/hazards/spike-block.glb',
                        'saw': 'assets/models/hazards/saw.glb'
                    }
                };
            }
            
            async loadLevel(levelNumber) {
                try {
                    this.clearLevel();
                    
                    const levelData = this.getEnhancedLevelData(levelNumber);
                    this.currentLevel = levelNumber;
                    
                    await this.createLevelObjects(levelData);
                    this.countTotalCoins();
                    
                    console.log(`Enhanced Level ${levelNumber} loaded successfully`);
                    return true;
                    
                } catch (error) {
                    console.error(`Failed to load level ${levelNumber}:`, error);
                    return false;
                }
            }
            
            getEnhancedLevelData(levelNumber) {
                switch(levelNumber) {
                    case 1:
                        return {
                            name: "Floating Gardens - Enhanced",
                            spawn: { x: 0, y: 5, z: 0 },
                            platforms: [
                                // Starting area
                                { type: "grass", position: { x: 0, y: 0, z: 0 }, scale: { x: 3, y: 1, z: 3 } },
                                
                                // Spiral tower - main feature requiring camera rotation
                                { type: "grass", position: { x: 8, y: 2, z: 0 }, scale: { x: 2, y: 1, z: 2 } },
                                { type: "grass-corner", position: { x: 12, y: 4, z: 4 }, scale: { x: 1.5, y: 1, z: 1.5 } },
                                { type: "grass", position: { x: 8, y: 6, z: 8 }, scale: { x: 2, y: 1, z: 2 } },
                                { type: "grass-corner", position: { x: 4, y: 8, z: 4 }, scale: { x: 1.5, y: 1, z: 1.5 } },
                                { type: "grass", position: { x: 8, y: 10, z: 0 }, scale: { x: 2, y: 1, z: 2 } },
                                { type: "grass-large", position: { x: 8, y: 12, z: -4 }, scale: { x: 2, y: 1, z: 2 } },
                                
                                // Hidden paths requiring camera movement
                                { type: "platform", position: { x: -6, y: 3, z: 6 }, scale: { x: 1.5, y: 0.5, z: 1.5 } },
                                { type: "platform", position: { x: -8, y: 5, z: -8 }, scale: { x: 1.5, y: 0.5, z: 1.5 } },
                                { type: "grass-curve", position: { x: 16, y: 6, z: -6 }, scale: { x: 1.5, y: 1, z: 1.5 } },
                                
                                // Vertical challenge section
                                { type: "grass", position: { x: 20, y: 2, z: 0 }, scale: { x: 1.5, y: 1, z: 1.5 } },
                                { type: "grass", position: { x: 22, y: 5, z: 3 }, scale: { x: 1.5, y: 1, z: 1.5 } },
                                { type: "grass", position: { x: 20, y: 8, z: 6 }, scale: { x: 1.5, y: 1, z: 1.5 } },
                                { type: "grass", position: { x: 18, y: 11, z: 3 }, scale: { x: 1.5, y: 1, z: 1.5 } },
                                { type: "grass-large", position: { x: 20, y: 14, z: 0 }, scale: { x: 2, y: 1, z: 2 } },
                                
                                // Moving platforms
                                { type: "platform", position: { x: 15, y: 8, z: 0 }, scale: { x: 1.5, y: 0.5, z: 1.5 }, moving: true, path: [
                                    { x: 15, y: 8, z: 0 }, { x: 15, y: 8, z: 6 }, { x: 15, y: 8, z: 0 }
                                ]},
                                { type: "platform", position: { x: 12, y: 12, z: -2 }, scale: { x: 1.5, y: 0.5, z: 1.5 }, moving: true, path: [
                                    { x: 12, y: 12, z: -2 }, { x: 6, y: 12, z: -2 }, { x: 12, y: 12, z: -2 }
                                ]}
                            ],
                            collectibles: [
                                // Coins along the spiral
                                { type: "coin-gold", position: { x: 10, y: 3, z: 2 } },
                                { type: "coin-gold", position: { x: 10, y: 7, z: 6 } },
                                { type: "coin-gold", position: { x: 6, y: 9, z: 2 } },
                                { type: "coin-silver", position: { x: 10, y: 11, z: -2 } },
                                { type: "coin-gold", position: { x: 10, y: 13, z: -6 } },
                                
                                // Hidden collectibles
                                { type: "jewel", position: { x: -6, y: 6, z: 6 } },
                                { type: "key", position: { x: -8, y: 8, z: -8 } },
                                { type: "heart", position: { x: 16, y: 9, z: -6 } },
                                
                                // Vertical challenge rewards
                                { type: "coin-gold", position: { x: 22, y: 8, z: 3 } },
                                { type: "coin-gold", position: { x: 20, y: 11, z: 6 } },
                                { type: "jewel", position: { x: 20, y: 17, z: 0 } }
                            ],
                            environment: [
                                // Trees creating visual barriers requiring camera movement
                                { type: "tree", position: { x: 4, y: 0, z: -8 }, scale: { x: 1.2, y: 1.2, z: 1.2 } },
                                { type: "tree-pine", position: { x: -4, y: 0, z: 8 }, scale: { x: 1, y: 1, z: 1 } },
                                { type: "tree", position: { x: 12, y: 6, z: -10 }, scale: { x: 1.5, y: 1.5, z: 1.5 } },
                                
                                // Environmental decoration
                                { type: "flowers", position: { x: 2, y: 1, z: 2 }, scale: { x: 0.8, y: 0.8, z: 0.8 } },
                                { type: "rocks", position: { x: -2, y: 1, z: -3 }, scale: { x: 0.6, y: 0.6, z: 0.6 } },
                                { type: "grass", position: { x: 6, y: 2, z: 4 }, scale: { x: 1, y: 1, z: 1 } },
                                
                                // Around the spiral
                                { type: "flowers", position: { x: 14, y: 4, z: 2 }, scale: { x: 0.9, y: 0.9, z: 0.9 } },
                                { type: "rocks", position: { x: 6, y: 8, z: 10 }, scale: { x: 0.7, y: 0.7, z: 0.7 } },
                                { type: "tree-pine", position: { x: 24, y: 14, z: 4 }, scale: { x: 1.3, y: 1.3, z: 1.3 } }
                            ],
                            interactive: [
                                { type: "flag", position: { x: 20, y: 17, z: 0 }, action: "level_complete" },
                                { type: "crate", position: { x: 8, y: 13, z: -2 } },
                                { type: "chest", position: { x: -6, y: 4, z: 6 } }
                            ],
                            hazards: [
                                { type: "spike", position: { x: 10, y: 2, z: -2 }, damage: 1 },
                                { type: "saw", position: { x: 14, y: 9, z: 4 }, damage: 1 }
                            ]
                        };
                    case 2:
                        return {
                            name: "Industrial Maze - Enhanced",
                            spawn: { x: 0, y: 5, z: 0 },
                            platforms: [
                                // Multi-level industrial complex
                                { type: "platform", position: { x: 0, y: 0, z: 0 }, scale: { x: 3, y: 1, z: 3 } },
                                
                                // Lower level maze
                                { type: "platform", position: { x: 6, y: 2, z: 0 }, scale: { x: 2, y: 1, z: 2 } },
                                { type: "platform", position: { x: 6, y: 2, z: -6 }, scale: { x: 2, y: 1, z: 2 } },
                                { type: "platform", position: { x: 0, y: 2, z: -6 }, scale: { x: 2, y: 1, z: 2 } },
                                { type: "platform", position: { x: -6, y: 2, z: -6 }, scale: { x: 2, y: 1, z: 2 } },
                                { type: "platform", position: { x: -6, y: 2, z: 0 }, scale: { x: 2, y: 1, z: 2 } },
                                
                                // Mid level with bridges
                                { type: "grass-corner", position: { x: 12, y: 6, z: 0 }, scale: { x: 1.5, y: 1, z: 1.5 } },
                                { type: "grass-corner", position: { x: 12, y: 6, z: -12 }, scale: { x: 1.5, y: 1, z: 1.5 } },
                                { type: "grass-corner", position: { x: -12, y: 6, z: -12 }, scale: { x: 1.5, y: 1, z: 1.5 } },
                                { type: "grass-corner", position: { x: -12, y: 6, z: 0 }, scale: { x: 1.5, y: 1, z: 1.5 } },
                                
                                // Upper level towers
                                { type: "grass-large", position: { x: 18, y: 12, z: -6 }, scale: { x: 2, y: 1, z: 2 } },
                                { type: "grass-large", position: { x: -18, y: 12, z: -6 }, scale: { x: 2, y: 1, z: 2 } },
                                
                                // Final platform
                                { type: "grass-large", position: { x: 0, y: 18, z: -6 }, scale: { x: 3, y: 1, z: 3 } }
                            ],
                            collectibles: [
                                { type: "coin-gold", position: { x: 6, y: 5, z: -3 } },
                                { type: "coin-silver", position: { x: 0, y: 5, z: -6 } },
                                { type: "coin-gold", position: { x: -6, y: 5, z: -3 } },
                                { type: "jewel", position: { x: 12, y: 9, z: -6 } },
                                { type: "key", position: { x: -12, y: 9, z: -6 } },
                                { type: "heart", position: { x: 0, y: 21, z: -6 } }
                            ],
                            environment: [
                                { type: "rocks", position: { x: 3, y: 2, z: 3 } },
                                { type: "rocks", position: { x: -3, y: 2, z: -9 } },
                                { type: "tree-pine", position: { x: 20, y: 12, z: -10 } },
                                { type: "tree-pine", position: { x: -20, y: 12, z: -2 } }
                            ],
                            interactive: [
                                { type: "flag", position: { x: 0, y: 21, z: -6 }, action: "level_complete" }
                            ],
                            hazards: [
                                { type: "spike", position: { x: 3, y: 2, z: -3 }, damage: 1 },
                                { type: "spike", position: { x: -3, y: 2, z: -3 }, damage: 1 },
                                { type: "saw", position: { x: 9, y: 6, z: -6 }, damage: 1 },
                                { type: "saw", position: { x: -9, y: 6, z: -6 }, damage: 1 }
                            ]
                        };
                    default:
                        return this.getEnhancedLevelData(1);
                }
            }
            
            async createLevelObjects(levelData) {
                for (const category of ['platforms', 'collectibles', 'environment', 'interactive', 'hazards']) {
                    if (levelData[category]) {
                        for (const objectData of levelData[category]) {
                            const object = await this.createObject(category, objectData);
                            if (object) {
                                this[category].push(object);
                                this.scene.add(object);
                                
                                // Handle moving platforms
                                if (objectData.moving && objectData.path) {
                                    object.userData.moving = true;
                                    object.userData.path = objectData.path;
                                    object.userData.pathIndex = 0;
                                    object.userData.pathDirection = 1;
                                    this.movingPlatforms.push(object);
                                }
                            }
                        }
                    }
                }
            }
            
            async createObject(category, objectData) {
                const assetPath = this.assetPaths[category]?.[objectData.type];
                
                try {
                    let object = Utils.cloneModel(assetPath);
                    
                    if (!object) {
                        const loadedModel = await Utils.loadModel(assetPath, this.gltfLoader);
                        object = loadedModel.clone();
                    }
                    
                    this.applyTransformations(object, objectData);
                    
                    if (category === 'collectibles') {
                        object.userData = {
                            type: objectData.type,
                            collected: false,
                            originalPosition: object.position.clone()
                        };
                    } else if (category === 'hazards') {
                        object.userData = {
                            type: objectData.type,
                            damage: objectData.damage || 1
                        };
                    } else if (category === 'interactive') {
                        object.userData = {
                            type: objectData.type,
                            action: objectData.action || 'none'
                        };
                    }
                    
                    return object;
                    
                } catch (error) {
                    console.warn(`Failed to create object: ${category}:${objectData.type}`);
                    return null;
                }
            }
            
            applyTransformations(object, objectData) {
                if (objectData.position) {
                    object.position.set(
                        objectData.position.x || 0,
                        objectData.position.y || 0,
                        objectData.position.z || 0
                    );
                }
                
                if (objectData.rotation) {
                    object.rotation.set(
                        Utils.degToRad(objectData.rotation.x || 0),
                        Utils.degToRad(objectData.rotation.y || 0),
                        Utils.degToRad(objectData.rotation.z || 0)
                    );
                }
                
                if (objectData.scale) {
                    object.scale.set(
                        objectData.scale.x || 1,
                        objectData.scale.y || 1,
                        objectData.scale.z || 1
                    );
                }
            }
            
            update() {
                // Animate collectibles
                this.collectibles.forEach(collectible => {
                    if (!collectible.userData.collected) {
                        Utils.animateRotate(collectible, 0, 0.02, 0);
                        Utils.animateFloat(collectible, 0.005, 0.1);
                    }
                });
                
                // Animate hazards
                this.hazards.forEach(hazard => {
                    if (hazard.userData.type === 'saw') {
                        Utils.animateRotate(hazard, 0, 0, 0.1);
                    }
                });
                
                // Update moving platforms
                this.movingPlatforms.forEach(platform => {
                    this.updateMovingPlatform(platform);
                });
            }
            
            updateMovingPlatform(platform) {
                const userData = platform.userData;
                if (!userData.moving || !userData.path) return;
                
                const path = userData.path;
                const speed = 0.02;
                
                const currentTarget = path[userData.pathIndex];
                const targetPos = new THREE.Vector3(currentTarget.x, currentTarget.y, currentTarget.z);
                
                platform.position.lerp(targetPos, speed);
                
                // Check if reached target
                if (platform.position.distanceTo(targetPos) < 0.1) {
                    userData.pathIndex += userData.pathDirection;
                    
                    // Reverse direction at path ends
                    if (userData.pathIndex >= path.length - 1 || userData.pathIndex <= 0) {
                        userData.pathDirection *= -1;
                        userData.pathIndex = Utils.clamp(userData.pathIndex, 0, path.length - 1);
                    }
                }
            }
            
            clearLevel() {
                [...this.platforms, ...this.collectibles, ...this.hazards, 
                 ...this.environment, ...this.interactive].forEach(obj => {
                    this.scene.remove(obj);
                });
                
                this.platforms = [];
                this.collectibles = [];
                this.hazards = [];
                this.environment = [];
                this.interactive = [];
                this.movingPlatforms = [];
                this.totalCoins = 0;
            }
            
            countTotalCoins() {
                this.totalCoins = this.collectibles.filter(item => 
                    item.userData.type && item.userData.type.includes('coin')
                ).length;
                
                Utils.updateUI('totalCoins', this.totalCoins);
            }
            
            getPlayerSpawnPosition() {
                return new THREE.Vector3(0, 5, 0);
            }
            
            checkLevelComplete() {
                const collectedCoins = this.collectibles.filter(item => 
                    item.userData.type && 
                    item.userData.type.includes('coin') && 
                    item.userData.collected
                ).length;
                return collectedCoins >= this.totalCoins;
            }
            
            resetCollectibles() {
                this.collectibles.forEach(collectible => {
                    collectible.userData.collected = false;
                    collectible.visible = true;
                    collectible.position.copy(collectible.userData.originalPosition);
                });
            }
            
            getPlatforms() {
                return [...this.platforms, ...this.movingPlatforms];
            }
            
            getCollectibles() {
                return this.collectibles;
            }
            
            getHazards() {
                return this.hazards;
            }
        }

        // Main Game class
        class Game {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.cameraController = null;
                
                this.loadingManager = null;
                this.gltfLoader = null;
                
                this.player = null;
                this.level = null;
                
                this.gameState = {
                    isPlaying: false,
                    isPaused: false,
                    isLoading: true,
                    currentLevel: 1,
                    score: 0,
                    coins: 0,
                    lives: 3
                };
                
                this.animationId = null;
            }
            
            async init() {
                console.log('Initializing Enhanced 3D Platformer...');
                
                try {
                    this.setupScene();
                    this.setupCamera();
                    this.setupRenderer();
                    this.setupLighting();
                    this.setupLoading();
                    
                    await this.loadAssets();
                    
                    this.player = new Player(this.scene);
                    this.level = new Level(this.scene, this.gltfLoader);
                    this.cameraController = new CameraController(this.camera, this.player);
                    
                    this.setupInput();
                    this.setupUI();
                    
                    await this.loadLevel(1);
                    this.startGame();
                    
                } catch (error) {
                    console.error('Failed to initialize game:', error);
                    this.showError('Failed to load game. Please refresh and try again.');
                }
            }
            
            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
            }
            
            setupCamera() {
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 10, 15);
            }
            
            setupRenderer() {
                this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.setClearColor(0x87CEEB);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                document.getElementById('gameContainer').appendChild(this.renderer.domElement);
            }
            
            setupLighting() {
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(50, 50, 50);
                directionalLight.castShadow = true;
                
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                
                this.scene.add(directionalLight);
                
                const fillLight = new THREE.DirectionalLight(0x87CEEB, 0.3);
                fillLight.position.set(-30, 20, -30);
                this.scene.add(fillLight);
            }
            
            setupLoading() {
                this.loadingManager = new THREE.LoadingManager();
                this.gltfLoader = new THREE.GLTFLoader(this.loadingManager);
                
                this.loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
                    const progress = (itemsLoaded / itemsTotal) * 100;
                    Utils.updateLoadingProgress(progress);
                };
                
                this.loadingManager.onLoad = () => {
                    this.gameState.isLoading = false;
                };
            }
            
            async loadAssets() {
                // For demo purposes, we'll simulate asset loading
                for (let i = 0; i <= 100; i += 10) {
                    Utils.updateLoadingProgress(i);
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                console.log('Enhanced assets loaded');
            }
            
            setupInput() {
                document.addEventListener('keydown', (event) => {
                    switch(event.code) {
                        case 'KeyR':
                            this.restartLevel();
                            break;
                        case 'KeyN':
                            this.nextLevel();
                            break;
                        case 'KeyP':
                        case 'Escape':
                            this.togglePause();
                            break;
                    }
                });
                
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            setupUI() {
                this.updateUI();
                Utils.showGameUI();
            }
            
            async loadLevel(levelNumber) {
                console.log(`Loading enhanced level ${levelNumber}...`);
                
                try {
                    const success = await this.level.loadLevel(levelNumber);
                    
                    if (success) {
                        this.gameState.currentLevel = levelNumber;
                        
                        const spawnPos = this.level.getPlayerSpawnPosition();
                        this.player.reset(spawnPos);
                        
                        this.gameState.coins = 0;
                        this.updateUI();
                        
                        console.log(`Enhanced Level ${levelNumber} loaded successfully`);
                        return true;
                    } else {
                        throw new Error(`Failed to load level ${levelNumber}`);
                    }
                    
                } catch (error) {
                    console.error(`Error loading level ${levelNumber}:`, error);
                    this.showError(`Failed to load level ${levelNumber}`);
                    return false;
                }
            }
            
            startGame() {
                this.gameState.isPlaying = true;
                this.gameState.isPaused = false;
                this.animate();
                console.log('Enhanced 3D Platformer started!');
            }
            
            animate() {
                if (!this.gameState.isPlaying) return;
                
                this.animationId = requestAnimationFrame(() => this.animate());
                
                if (!this.gameState.isPaused) {
                    this.update();
                    this.render();
                }
            }
            
            update() {
                if (!this.player || !this.level) return;
                
                this.player.update(
                    this.level.getPlatforms(),
                    this.level.getCollectibles(),
                    this.level.getHazards()
                );
                
                this.cameraController.update();
                this.level.update();
                
                if (this.level.checkLevelComplete()) {
                    this.levelComplete();
                }
                
                this.updateUI();
            }
            
            render() {
                this.renderer.render(this.scene, this.camera);
            }
            
            levelComplete() {
                const nextLevel = this.gameState.currentLevel + 1;
                
                if (nextLevel <= 2) {
                    Utils.showMessage(
                        'Level Complete!',
                        `Excellent work with the 3D navigation! Ready for level ${nextLevel}?`,
                        'Next Level',
                        () => {
                            Utils.hideMessage();
                            this.loadLevel(nextLevel);
                        }
                    );
                } else {
                    Utils.showMessage(
                        'Demo Complete!',
                        `Congratulations! You've mastered the enhanced 3D platformer!\\nFinal Score: ${this.gameState.score}\\n\\nThis demo showcases advanced camera controls and 3D level design.`,
                        'Play Again',
                        () => {
                            Utils.hideMessage();
                            this.loadLevel(1);
                            this.gameState.score = 0;
                        }
                    );
                }
            }
            
            playerDied() {
                if (this.gameState.lives <= 0) {
                    Utils.showMessage(
                        'Game Over',
                        `Better luck next time!\\nFinal Score: ${this.gameState.score}`,
                        'Restart',
                        () => {
                            Utils.hideMessage();
                            this.restartGame();
                        }
                    );
                } else {
                    this.restartLevel();
                }
            }
            
            restartLevel() {
                console.log('Restarting level...');
                
                const spawnPos = this.level.getPlayerSpawnPosition();
                this.player.reset(spawnPos);
                this.player.lives = this.gameState.lives;
                
                this.level.resetCollectibles();
                this.gameState.coins = 0;
                this.updateUI();
            }
            
            restartGame() {
                this.gameState.score = 0;
                this.gameState.coins = 0;
                this.gameState.lives = 3;
                this.gameState.currentLevel = 1;
                
                this.player.lives = 3;
                this.player.isAlive = true;
                
                this.loadLevel(1);
            }
            
            nextLevel() {
                const nextLevel = this.gameState.currentLevel + 1;
                if (nextLevel <= 2) {
                    this.loadLevel(nextLevel);
                }
            }
            
            togglePause() {
                this.gameState.isPaused = !this.gameState.isPaused;
                Utils.togglePauseMenu(this.gameState.isPaused);
            }
            
            resumeGame() {
                this.gameState.isPaused = false;
                Utils.togglePauseMenu(false);
            }
            
            addScore(points) {
                this.gameState.score += points;
            }
            
            addCoin() {
                this.gameState.coins++;
            }
            
            updateUI() {
                Utils.updateUI('score', this.gameState.score);
                Utils.updateUI('lives', this.player ? this.player.lives : this.gameState.lives);
                Utils.updateUI('coins', this.gameState.coins);
                Utils.updateUI('currentLevel', this.gameState.currentLevel);
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            showError(message) {
                Utils.showMessage('Error', message, 'OK', () => Utils.hideMessage());
            }
            
            hideMessage() {
                Utils.hideMessage();
            }
        }

        // Initialize game
        const game = new Game();
        
        window.addEventListener('load', () => {
            game.init();
        });
    </script>
</body>
</html>