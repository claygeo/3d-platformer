<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced 3D Exploration Game</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #gameUI { position: absolute; top: 10px; left: 10px; color: white; text-shadow: 1px 1px 2px black; }
        #gameUI div { margin-bottom: 5px; font-size: 18px; }
        #controls, #cameraControls { position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; color: white; }
        #cameraMode { position: absolute; bottom: 10px; left: 10px; color: white; }
        #loading { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; }
        #loadingBar { width: 300px; height: 20px; background: #333; border-radius: 10px; overflow: hidden; }
        #loadingFill { height: 100%; background: #4CAF50; width: 0; transition: width 0.3s; }
        #gameMessage, #pauseMenu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; flex-direction: column; color: white; }
        #gameMessage.hidden, #pauseMenu.hidden { display: none; }
        button { padding: 10px 20px; margin: 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; }
        button:hover { background: #45a049; }
        .fade-in { animation: fadeIn 1s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    </style>
</head>
<body>
    <div id="loading">
        <h1>Enhanced 3D Exploration Game</h1>
        <p>Loading Enhanced Assets...</p>
        <div id="loadingBar"><div id="loadingFill"></div></div>
        <span id="loadingPercent">0%</span>
    </div>

    <div id="gameUI" style="display: none;">
        <div>Score: <span id="score">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
        <div>Coins: <span id="coins">0</span>/<span id="totalCoins">0</span></div>
        <div>Keys: <span id="keys">0</span></div>
        <div>Level: <span id="currentLevel">1</span></div>
    </div>

    <div id="cameraControls" class="hidden">
        <h3>Enhanced Camera</h3>
        <p>Mouse Drag: Orbit Camera</p>
        <p>Scroll Wheel: Zoom</p>
        <p>C: Toggle Camera Mode</p>
        <p>F: Focus Player</p>
    </div>

    <div id="controls">
        <h3>Controls</h3>
        <p>WASD: Move</p>
        <p>Space: Jump</p>
        <p>Shift: Sprint</p>
        <p>E: Interact</p>
        <p>L: Climb Ladder</p>
        <p>R: Restart Level</p>
        <p>ESC: Pause</p>
    </div>

    <div id="cameraMode">Camera Mode: Free Orbit</div>

    <div id="gameMessage" class="hidden">
        <h1 id="messageTitle">Level Complete!</h1>
        <p id="messageText">Great job! Moving to next level...</p>
        <button id="messageButton">Continue</button>
    </div>

    <div id="pauseMenu" class="hidden">
        <h1>Game Paused</h1>
        <button onclick="game.resumeGame()">Resume</button>
        <button onclick="game.restartLevel()">Restart Level</button>
        <button onclick="game.restartGame()">Back to Level 1</button>
    </div>

    <div id="gameContainer"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // Utils Class
        const Utils = {
            loadedModels: {},
            loadModel(path, loader) {
                return new Promise((resolve, reject) => {
                    loader.load(
                        path,
                        (gltf) => {
                            const model = gltf.scene;
                            model.traverse((child) => {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                }
                            });
                            this.loadedModels[path] = model;
                            resolve(model);
                        },
                        undefined,
                        (error) => {
                            console.warn(`Failed to load model: ${path}`, error);
                            reject(error);
                        }
                    );
                });
            },
            cloneModel(path) {
                if (!this.loadedModels[path]) {
                    console.warn(`Model not loaded: ${path}`);
                    return null;
                }
                return this.loadedModels[path].clone();
            },
            createFallbackGeometry(type = 'box', color = 0x4CAF50, size = [1, 1, 1]) {
                let geometry;
                switch(type) {
                    case 'sphere': geometry = new THREE.SphereGeometry(size[0], 16, 16); break;
                    case 'cylinder': geometry = new THREE.CylinderGeometry(size[0], size[1], size[2], 16); break;
                    default: geometry = new THREE.BoxGeometry(size[0], size[1], size[2]); break;
                }
                const material = new THREE.MeshLambertMaterial({ color });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            },
            distance(pos1, pos2) { return pos1.distanceTo(pos2); },
            isColliding(obj1, obj2, threshold = 2) { return this.distance(obj1.position, obj2.position) < threshold; },
            isOnPlatform(player, platform, threshold = 3) {
                const horizontalDistance = Math.sqrt(
                    Math.pow(player.position.x - platform.position.x, 2) +
                    Math.pow(player.position.z - platform.position.z, 2)
                );
                const verticalDistance = player.position.y - platform.position.y;
                return horizontalDistance < threshold && verticalDistance > 0.5 && verticalDistance < 3;
            },
            lerp(start, end, factor) { return start + (end - start) * factor; },
            clamp(value, min, max) { return Math.max(min, Math.min(max, value)); },
            degToRad(degrees) { return degrees * (Math.PI / 180); },
            radToDeg(radians) { return radians * (180 / Math.PI); },
            random(min, max) { return Math.random() * (max - min) + min; },
            randomChoice(array) { return array[Math.floor(Math.random() * array.length)]; },
            animateFloat(object, speed = 0.005, amplitude = 0.3, offset = 0) {
                const time = Date.now() * speed + offset;
                object.position.y += Math.sin(time) * amplitude * 0.016;
            },
            animateRotate(object, speedX = 0, speedY = 0.02, speedZ = 0) {
                object.rotation.x += speedX;
                object.rotation.y += speedY;
                object.rotation.z += speedZ;
            },
            updateUI(id, value) {
                const element = document.getElementById(id);
                if (element) element.textContent = value;
            },
            showMessage(title, text, buttonText = 'Continue', callback = null) {
                const messageDiv = document.getElementById('gameMessage');
                const titleElement = document.getElementById('messageTitle');
                const textElement = document.getElementById('messageText');
                const buttonElement = document.getElementById('messageButton');
                titleElement.textContent = title;
                textElement.textContent = text;
                buttonElement.textContent = buttonText;
                if (callback) buttonElement.onclick = callback;
                messageDiv.classList.remove('hidden');
            },
            hideMessage() { document.getElementById('gameMessage').classList.add('hidden'); },
            togglePauseMenu(show) {
                const pauseMenu = document.getElementById('pauseMenu');
                if (show) pauseMenu.classList.remove('hidden');
                else pauseMenu.classList.add('hidden');
            },
            updateLoadingProgress(progress) {
                const fillElement = document.getElementById('loadingFill');
                const percentElement = document.getElementById('loadingPercent');
                if (fillElement) fillElement.style.width = progress + '%';
                if (percentElement) percentElement.textContent = Math.round(progress) + '%';
            },
            showGameUI() {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('gameUI').style.display = 'block';
                document.getElementById('gameUI').classList.add('fade-in');
            },
            createParticleEffect(scene, position, color = 0xFFD700) {
                const particles = [];
                const particleCount = 10;
                for (let i = 0; i < particleCount; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05, 8, 8),
                        new THREE.MeshBasicMaterial({ color })
                    );
                    particle.position.copy(position);
                    particle.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2,
                        Math.random() * 0.2,
                        (Math.random() - 0.5) * 0.2
                    );
                    particle.life = 1.0;
                    particles.push(particle);
                    scene.add(particle);
                }
                const animateParticles = () => {
                    particles.forEach((particle, index) => {
                        particle.position.add(particle.velocity);
                        particle.velocity.y -= 0.01;
                        particle.life -= 0.02;
                        particle.material.opacity = particle.life;
                        if (particle.life <= 0) {
                            scene.remove(particle);
                            particles.splice(index, 1);
                        }
                    });
                    if (particles.length > 0) requestAnimationFrame(animateParticles);
                };
                animateParticles();
            }
        };

        // Player Class
        class Player {
            constructor(scene) {
                this.scene = scene;
                this.mesh = null;
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.position = new THREE.Vector3(0, 5, 0);
                this.rotation = 0;
                this.speed = 0.15;
                this.jumpForce = 0.4;
                this.gravity = -0.02;
                this.isGrounded = false;
                this.isJumping = false;
                this.isClimbing = false;
                this.lives = 3;
                this.isAlive = true;
                this.keysCollected = 0;
                this.keys = { left: false, right: false, forward: false, backward: false, space: false, shift: false, interact: false, climb: false };
                this.camera = null;
                this.cameraMode = 'follow';
                this.orbitControls = null;
                this.init();
                this.setupInput();
            }
            init() {
                const geometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
                const material = new THREE.MeshLambertMaterial({ color: 0x4CAF50, transparent: true, opacity: 0.9 });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                const faceGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const faceMaterial = new THREE.MeshBasicMaterial({ color: 0x2196F3 });
                this.face = new THREE.Mesh(faceGeometry, faceMaterial);
                this.face.position.set(0, 0.3, 0.4);
                this.mesh.add(this.face);
                this.scene.add(this.mesh);
            }
            setupInput() {
                document.addEventListener('keydown', (event) => {
                    switch(event.code) {
                        case 'KeyW': case 'ArrowUp': this.keys.forward = true; break;
                        case 'KeyS': case 'ArrowDown': this.keys.backward = true; break;
                        case 'KeyA': case 'ArrowLeft': this.keys.left = true; break;
                        case 'KeyD': case 'ArrowRight': this.keys.right = true; break;
                        case 'Space': this.keys.space = true; break;
                        case 'ShiftLeft': case 'ShiftRight': this.keys.shift = true; break;
                        case 'KeyE': this.keys.interact = true; break;
                        case 'KeyL': this.keys.climb = true; break;
                        case 'KeyC': this.toggleCameraMode(); break;
                        case 'KeyF': this.focusCamera(); break;
                    }
                    if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.code)) {
                        event.preventDefault();
                    }
                });
                document.addEventListener('keyup', (event) => {
                    switch(event.code) {
                        case 'KeyW': case 'ArrowUp': this.keys.forward = false; break;
                        case 'KeyS': case 'ArrowDown': this.keys.backward = false; break;
                        case 'KeyA': case 'ArrowLeft': this.keys.left = false; break;
                        case 'KeyD': case 'ArrowRight': this.keys.right = false; break;
                        case 'Space': this.keys.space = false; break;
                        case 'ShiftLeft': case 'ShiftRight': this.keys.shift = false; break;
                        case 'KeyE': this.keys.interact = false; break;
                        case 'KeyL': this.keys.climb = false; break;
                    }
                });
                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };
                document.addEventListener('mousedown', (e) => { isDragging = true; previousMousePosition = { x: e.clientX, y: e.clientY }; });
                document.addEventListener('mouseup', () => { isDragging = false; });
                document.addEventListener('mousemove', (e) => {
                    if (isDragging && this.cameraMode === 'orbit') {
                        const deltaMove = { x: e.clientX - previousMousePosition.x, y: e.clientY - previousMousePosition.y };
                        this.orbitControls.theta -= deltaMove.x * 0.005;
                        this.orbitControls.phi -= deltaMove.y * 0.005;
                        this.orbitControls.phi = Utils.clamp(this.orbitControls.phi, 0.1, Math.PI - 0.1);
                        previousMousePosition = { x: e.clientX, y: e.clientY };
                    }
                });
                document.addEventListener('wheel', (e) => {
                    if (this.cameraMode === 'orbit') {
                        this.orbitControls.distance += e.deltaY * 0.01;
                        this.orbitControls.distance = Utils.clamp(this.orbitControls.distance, 5, 50);
                    }
                });
                document.addEventListener('contextmenu', (event) => event.preventDefault());
            }
            toggleCameraMode() {
                this.cameraMode = this.cameraMode === 'follow' ? 'orbit' : 'follow';
                Utils.updateUI('cameraMode', `Camera Mode: ${this.cameraMode === 'follow' ? 'Follow' : 'Free Orbit'}`);
                document.getElementById('cameraControls').classList.toggle('hidden', this.cameraMode === 'follow');
            }
            focusCamera() {
                if (this.cameraMode === 'orbit') {
                    this.orbitControls.theta = -Math.PI / 2;
                    this.orbitControls.phi = Math.PI / 4;
                    this.orbitControls.distance = 12;
                }
            }
            update(platforms = [], collectibles = [], hazards = [], interactive = []) {
                if (!this.isAlive) return;
                this.updateMovement();
                this.updatePhysics();
                this.checkPlatformCollisions(platforms);
                this.checkCollectibleCollisions(collectibles);
                this.checkHazardCollisions(hazards);
                this.checkInteractiveCollisions(interactive);
                this.checkBoundaries();
                this.updateMesh();
            }
            updateMovement() {
                const currentSpeed = this.keys.shift ? this.speed * 1.5 : this.speed;
                if (this.keys.left) this.velocity.x = -currentSpeed;
                else if (this.keys.right) this.velocity.x = currentSpeed;
                else this.velocity.x *= 0.8;
                if (this.keys.forward) this.velocity.z = -currentSpeed;
                else if (this.keys.backward) this.velocity.z = currentSpeed;
                else this.velocity.z *= 0.8;
                if (this.keys.space && this.isGrounded && !this.isJumping) {
                    this.velocity.y = this.jumpForce;
                    this.isGrounded = false;
                    this.isJumping = true;
                    if (this.jumpSound) this.jumpSound.play();
                }
                if (this.isClimbing && this.keys.climb) {
                    this.velocity.y = 0.1;
                    this.gravity = 0;
                } else {
                    this.gravity = -0.02;
                }
                const maxSpeed = currentSpeed * 1.2;
                this.velocity.x = Utils.clamp(this.velocity.x, -maxSpeed, maxSpeed);
                this.velocity.z = Utils.clamp(this.velocity.z, -maxSpeed, maxSpeed);
            }
            updatePhysics() {
                if (!this.isGrounded) this.velocity.y += this.gravity;
                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;
                this.position.z += this.velocity.z;
                if (this.position.y <= 1) {
                    this.position.y = 1;
                    this.velocity.y = 0;
                    this.isGrounded = true;
                    this.isJumping = false;
                    this.isClimbing = false;
                }
            }
            checkPlatformCollisions(platforms) {
                let onPlatform = false;
                platforms.forEach(platform => {
                    if (Utils.isOnPlatform(this, platform)) {
                        if (this.velocity.y <= 0) {
                            this.position.y = platform.position.y + 2;
                            this.velocity.y = 0;
                            this.isGrounded = true;
                            this.isJumping = false;
                            this.isClimbing = false;
                            onPlatform = true;
                        }
                    }
                });
                if (!onPlatform && this.position.y > 1.1) this.isGrounded = false;
            }
            checkCollectibleCollisions(collectibles) {
                collectibles.forEach(collectible => {
                    if (!collectible.userData.collected && Utils.isColliding(this, collectible, 1.5)) {
                        this.collectItem(collectible);
                    }
                });
            }
            checkHazardCollisions(hazards) {
                hazards.forEach(hazard => {
                    if (Utils.isColliding(this, hazard, 1.5)) {
                        this.takeDamage();
                    }
                });
            }
            checkInteractiveCollisions(interactive) {
                interactive.forEach(obj => {
                    if (Utils.isColliding(this, obj, 2)) {
                        if (obj.userData.type === 'ladder' && this.keys.climb) {
                            this.isClimbing = true;
                            this.position.x = obj.position.x;
                            this.position.z = obj.position.z;
                        } else if (obj.userData.type === 'lever' && this.keys.interact && !obj.userData.activated) {
                            obj.userData.activated = true;
                            obj.rotation.z = Utils.degToRad(45);
                            game.unlockDoor();
                        } else if (obj.userData.type === 'chest' && this.keys.interact && !obj.userData.opened) {
                            obj.userData.opened = true;
                            obj.position.y += 0.5;
                            game.addScore(200);
                            Utils.createParticleEffect(this.scene, obj.position.clone(), 0xFFD700);
                        }
                    } else if (obj.userData.type === 'ladder') {
                        this.isClimbing = false;
                    }
                });
            }
            collectItem(collectible) {
                collectible.userData.collected = true;
                collectible.visible = false;
                Utils.createParticleEffect(this.scene, collectible.position.clone(), 0xFFD700);
                if (this.coinSound) this.coinSound.play();
                const type = collectible.userData.type || 'coin';
                switch(type) {
                    case 'coin-gold': game.addScore(100); game.addCoin(); break;
                    case 'coin-silver': game.addScore(50); game.addCoin(); break;
                    case 'coin-bronze': game.addScore(25); game.addCoin(); break;
                    case 'heart': this.addLife(); game.addScore(200); break;
                    case 'jewel': game.addScore(500); break;
                    case 'key': this.keysCollected++; game.addScore(300); Utils.updateUI('keys', this.keysCollected); break;
                    default: game.addScore(50); game.addCoin(); break;
                }
            }
            takeDamage() {
                if (!this.isAlive) return;
                this.lives--;
                Utils.updateUI('lives', this.lives);
                Utils.createParticleEffect(this.scene, this.position.clone(), 0xFF0000);
                this.velocity.y = 0.2;
                this.velocity.x *= -2;
                this.velocity.z *= -2;
                if (this.lives <= 0) this.die();
                else {
                    this.mesh.material.color.setHex(0xFF0000);
                    setTimeout(() => { this.mesh.material.color.setHex(0x4CAF50); }, 500);
                }
            }
            addLife() {
                this.lives++;
                Utils.updateUI('lives', this.lives);
            }
            die() {
                this.isAlive = false;
                this.mesh.material.color.setHex(0x666666);
                this.mesh.material.opacity = 0.5;
                setTimeout(() => { game.playerDied(); }, 1000);
            }
            checkBoundaries() {
                if (this.position.y < -20) {
                    this.takeDamage();
                    this.respawn();
                }
                const maxDistance = 200;
                this.position.x = Utils.clamp(this.position.x, -maxDistance, maxDistance);
                this.position.z = Utils.clamp(this.position.z, -maxDistance, maxDistance);
            }
            respawn() {
                const spawnPos = game.level.getPlayerSpawnPosition();
                this.position.copy(spawnPos);
                this.velocity.set(0, 0, 0);
                this.isGrounded = false;
                this.isJumping = false;
                this.isClimbing = false;
            }
            updateMesh() {
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    if (Math.abs(this.velocity.x) > 0.01 || Math.abs(this.velocity.z) > 0.01) {
                        const angle = Math.atan2(this.velocity.x, this.velocity.z);
                        this.mesh.rotation.y = Utils.lerp(this.mesh.rotation.y, angle, 0.1);
                    }
                    if (this.isGrounded && (Math.abs(this.velocity.x) > 0.01 || Math.abs(this.velocity.z) > 0.01)) {
                        this.mesh.position.y += Math.sin(Date.now() * 0.01) * 0.05;
                    }
                }
            }
            updateCamera(camera) {
                if (!camera) return;
                if (this.cameraMode === 'follow') {
                    const idealCameraPosition = new THREE.Vector3(
                        this.position.x,
                        this.position.y + 8,
                        this.position.z + 12
                    );
                    camera.position.lerp(idealCameraPosition, 0.05);
                    const lookAtPosition = new THREE.Vector3(
                        this.position.x + this.velocity.x * 2,
                        this.position.y + 1,
                        this.position.z + this.velocity.z * 2
                    );
                    camera.lookAt(lookAtPosition);
                } else {
                    const radius = this.orbitControls.distance;
                    const theta = this.orbitControls.theta;
                    const phi = this.orbitControls.phi;
                    camera.position.x = this.position.x + radius * Math.sin(theta) * Math.sin(phi);
                    camera.position.y = this.position.y + radius * Math.cos(phi);
                    camera.position.z = this.position.z + radius * Math.cos(theta) * Math.sin(phi);
                    camera.lookAt(this.position);
                }
            }
            reset(spawnPosition) {
                this.position.copy(spawnPosition);
                this.velocity.set(0, 0, 0);
                this.isGrounded = false;
                this.isJumping = false;
                this.isClimbing = false;
                this.isAlive = true;
                this.keysCollected = 0;
                Utils.updateUI('keys', this.keysCollected);
                if (this.mesh) {
                    this.mesh.material.color.setHex(0x4CAF50);
                    this.mesh.material.opacity = 0.9;
                    this.mesh.position.copy(this.position);
                }
                this.orbitControls = { theta: -Math.PI / 2, phi: Math.PI / 4, distance: 12 };
            }
            setupAudio(listener) {
                this.jumpSound = new THREE.Audio(listener);
                this.coinSound = new THREE.Audio(listener);
                new THREE.AudioLoader().load('assets/audio/jump.wav', (buffer) => {
                    this.jumpSound.setBuffer(buffer);
                    this.jumpSound.setVolume(0.5);
                });
                new THREE.AudioLoader().load('assets/audio/coin.wav', (buffer) => {
                    this.coinSound.setBuffer(buffer);
                    this.coinSound.setVolume(0.5);
                });
            }
        }

        // Level Class
        class Level {
            constructor(scene, gltfLoader) {
                this.scene = scene;
                this.gltfLoader = gltfLoader;
                this.platforms = [];
                this.collectibles = [];
                this.hazards = [];
                this.environment = [];
                this.interactive = [];
                this.currentLevel = 1;
                this.levelData = null;
                this.totalCoins = 0;
                this.unlockedDoors = [];
                this.assetPaths = {
                    platforms: {
                        'grass': 'assets/models/platforms/block-grass.glb',
                        'grass-large': 'assets/models/platforms/block-grass-large.glb',
                        'grass-corner': 'assets/models/platforms/block-grass-corner.glb',
                        'grass-curve': 'assets/models/platforms/block-grass-curve.glb',
                        'platform': 'assets/models/platforms/platform.glb',
                        'platform-ramp': 'assets/models/platforms/platform-ramp.glb',
                        'terrain-dirt': 'assets/models/platforms/block-grass-large.glb', // Replaced terrain-dirt
                        'terrain-rock': 'assets/models/platforms/block-snow-large.glb' // Replaced terrain-rock
                    },
                    collectibles: {
                        'coin-gold': 'assets/models/collectibles/coin-gold.glb',
                        'coin-silver': 'assets/models/collectibles/coin-silver.glb',
                        'coin-bronze': 'assets/models/collectibles/coin-bronze.glb',
                        'heart': 'assets/models/collectibles/heart.glb',
                        'jewel': 'assets/models/collectibles/jewel.glb',
                        'key': 'assets/models/collectibles/key.glb'
                    },
                    environment: {
                        'tree': 'assets/models/environment/tree.glb',
                        'tree-pine': 'assets/models/environment/tree-pine.glb',
                        'rocks': 'assets/models/environment/rocks.glb',
                        'grass': 'assets/models/environment/grass.glb',
                        'flowers': 'assets/models/environment/flowers.glb',
                        'hedge': 'assets/models/environment/hedge.glb', // Replaced bush
                        'mushroom': 'assets/models/environment/mushrooms.glb' // Replaced mushroom
                    },
                    interactive: {
                        'crate': 'assets/models/interactive/crate.glb',
                        'chest': 'assets/models/interactive/chest.glb',
                        'button': 'assets/models/interactive/button-round.glb',
                        'door': 'assets/models/interactive/door-rotate.glb',
                        'lever': 'assets/models/interactive/lever.glb',
                        'flag': 'assets/models/interactive/flag.glb',
                        'switch': 'assets/models/interactive/button-square.glb' // Replaced switch
                    },
                    hazards: {
                        'spike': 'assets/models/hazards/spike-block.glb',
                        'saw': 'assets/models/hazards/saw.glb',
                        'trap': 'assets/models/hazards/trap-spikes.glb',
                        'bomb': 'assets/models/hazards/bomb.glb'
                    },
                    structures: {
                        'fence': 'assets/models/structures/fence-low-straight.glb',
                        'ladder': 'assets/models/structures/ladder.glb',
                        'poles': 'assets/models/structures/poles.glb',
                        'bridge': 'assets/models/structures/platform-fortified.glb' // Replaced bridge
                    }
                };
                this.levelData = {
                    spawn: { x: 0, y: 5, z: 0 },
                    goal: { type: 'collect_keys', count: 2 },
                    platforms: [
                        { type: 'terrain-dirt', position: { x: 0, y: 0, z: 0 }, scale: { x: 20, y: 1, z: 20 } }, // Uses block-grass-large
                        { type: 'terrain-rock', position: { x: 15, y: 1, z: 10 }, scale: { x: 5, y: 2, z: 5 } }, // Uses block-snow-large
                        { type: 'platform-ramp', position: { x: -10, y: 1, z: 15 }, rotation: { y: 90 } },
                        { type: 'grass-large', position: { x: -15, y: 3, z: -10 }, scale: { x: 8, y: 1, z: 8 } }
                    ],
                    collectibles: [
                        { type: 'coin-gold', position: { x: 5, y: 2, z: 5 } },
                        { type: 'coin-silver', position: { x: -5, y: 2, z: -5 } },
                        { type: 'key', position: { x: 15, y: 3, z: 10 } },
                        { type: 'key', position: { x: -15, y: 4, z: -10 } },
                        { type: 'heart', position: { x: 0, y: 2, z: 15 } }
                    ],
                    hazards: [
                        { type: 'spike', position: { x: 10, y: 1, z: -5 } },
                        { type: 'saw', position: { x: -10, y: 2, z: 5 } }
                    ],
                    environment: [
                        { type: 'tree', position: { x: 8, y: 1, z: 8 }, scale: { x: 2, y: 2, z: 2 } },
                        { type: 'hedge', position: { x: -8, y: 1, z: 8 } }, // Uses hedge
                        { type: 'mushroom', position: { x: 0, y: 1, z: -8 } } // Uses mushrooms
                    ],
                    interactive: [
                        { type: 'ladder', position: { x: -15, y: 2, z: -10 }, scale: { x: 1, y: 2, z: 1 } },
                        { type: 'lever', position: { x: 5, y: 1, z: -5 } },
                        { type: 'door', position: { x: 15, y: 1, z: 0 }, userData: { locked: true } },
                        { type: 'chest', position: { x: 0, y: 1, z: -15 } },
                        { type: 'bridge', position: { x: 10, y: 2, z: -10 }, scale: { x: 5, y: 1, z: 2 } } // Uses platform-fortified
                    ]
                };
            }
            async loadLevel(levelNumber) {
                try {
                    this.clearLevel();
                    this.currentLevel = levelNumber;
                    await this.createPlatforms();
                    await this.createCollectibles();
                    await this.createHazards();
                    await this.createEnvironment();
                    await this.createInteractive();
                    this.countTotalCoins();
                    return true;
                } catch (error) {
                    console.error(`Failed to load level ${levelNumber}:`, error);
                    return false;
                }
            }
            clearLevel() {
                [...this.platforms, ...this.collectibles, ...this.hazards, ...this.environment, ...this.interactive].forEach(obj => this.scene.remove(obj));
                this.platforms = [];
                this.collectibles = [];
                this.hazards = [];
                this.environment = [];
                this.interactive = [];
                this.totalCoins = 0;
                this.unlockedDoors = [];
            }
            async createPlatforms() {
                if (!this.levelData.platforms) return;
                for (const platformData of this.levelData.platforms) {
                    const platform = await this.createObject('platforms', platformData);
                    if (platform) {
                        this.platforms.push(platform);
                        this.scene.add(platform);
                    }
                }
            }
            async createCollectibles() {
                if (!this.levelData.collectibles) return;
                for (const collectibleData of this.levelData.collectibles) {
                    const collectible = await this.createObject('collectibles', collectibleData);
                    if (collectible) {
                        collectible.userData = { type: collectibleData.type, collected: false, originalPosition: collectible.position.clone() };
                        this.collectibles.push(collectible);
                        this.scene.add(collectible);
                    }
                }
            }
            async createHazards() {
                if (!this.levelData.hazards) return;
                for (const hazardData of this.levelData.hazards) {
                    const hazard = await this.createObject('hazards', hazardData);
                    if (hazard) {
                        hazard.userData = { type: hazardData.type, damage: hazardData.damage || 1 };
                        this.hazards.push(hazard);
                        this.scene.add(hazard);
                    }
                }
            }
            async createEnvironment() {
                if (!this.levelData.environment) return;
                for (const envData of this.levelData.environment) {
                    const envObject = await this.createObject('environment', envData);
                    if (envObject) {
                        envObject.userData = { type: envData.type };
                        this.environment.push(envObject);
                        this.scene.add(envObject);
                    }
                }
            }
            async createInteractive() {
                if (!this.levelData.interactive) return;
                for (const interactiveData of this.levelData.interactive) {
                    const interactive = await this.createObject('interactive', interactiveData);
                    if (interactive) {
                        interactive.userData = { type: interactiveData.type, action: interactiveData.action || 'none', locked: interactiveData.userData?.locked || false, activated: false, opened: false };
                        this.interactive.push(interactive);
                        this.scene.add(interactive);
                    }
                }
            }
            async createObject(category, objectData) {
                const assetPath = this.assetPaths[category][objectData.type];
                if (!assetPath) {
                    console.warn(`Asset path not found for ${category}:${objectData.type}`);
                    return this.createFallbackObject(objectData);
                }
                try {
                    let object = Utils.cloneModel(assetPath);
                    if (!object) {
                        const loadedModel = await Utils.loadModel(assetPath, this.gltfLoader);
                        object = loadedModel.clone();
                    }
                    this.applyTransformations(object, objectData);
                    return object;
                } catch (error) {
                    console.warn(`Failed to load ${assetPath}, using fallback`);
                    return this.createFallbackObject(objectData);
                }
            }
            createFallbackObject(objectData) {
                const size = objectData.scale ? [objectData.scale.x || 1, objectData.scale.y || 1, objectData.scale.z || 1] : [1, 1, 1];
                const color = this.getFallbackColor(objectData.type);
                const geometry = this.getFallbackGeometry(objectData.type);
                const object = Utils.createFallbackGeometry(geometry, color, size);
                this.applyTransformations(object, objectData);
                return object;
            }
            getFallbackColor(type) {
                const colorMap = {
                    'grass': 0x4CAF50, 'platform': 0x9E9E9E, 'terrain-dirt': 0x4CAF50, 'terrain-rock': 0xD3D3D3,
                    'coin-gold': 0xFFD700, 'coin-silver': 0xC0C0C0, 'coin-bronze': 0xCD7F32, 'heart': 0xFF69B4, 'jewel': 0x9C27B0, 'key': 0xFFC107,
                    'spike': 0xFF5722, 'saw': 0xF44336, 'trap': 0xFF1744, 'bomb': 0x000000,
                    'tree': 0x2E7D32, 'rocks': 0x5D4037, 'grass': 0x4CAF50, 'flowers': 0xE91E63, 'hedge': 0x4CAF50, 'mushroom': 0xF4A460
                };
                return colorMap[type] || 0x808080;
            }
            getFallbackGeometry(type) {
                const geometryMap = { 'heart': 'sphere', 'coin-gold': 'cylinder', 'coin-silver': 'cylinder', 'coin-bronze': 'cylinder', 'tree': 'cylinder', 'saw': 'cylinder' };
                return geometryMap[type] || 'box';
            }
            applyTransformations(object, objectData) {
                if (objectData.position) object.position.set(objectData.position.x || 0, objectData.position.y || 0, objectData.position.z || 0);
                if (objectData.rotation) object.rotation.set(Utils.degToRad(objectData.rotation.x || 0), Utils.degToRad(objectData.rotation.y || 0), Utils.degToRad(objectData.rotation.z || 0));
                if (objectData.scale) object.scale.set(objectData.scale.x || 1, objectData.scale.y || 1, objectData.scale.z || 1);
            }
            countTotalCoins() {
                this.totalCoins = this.collectibles.filter(item => item.userData.type && item.userData.type.includes('coin')).length;
                Utils.updateUI('totalCoins', this.totalCoins);
            }
            update() {
                this.collectibles.forEach(collectible => {
                    if (!collectible.userData.collected) {
                        Utils.animateRotate(collectible, 0, 0.02, 0);
                        Utils.animateFloat(collectible, 0.005, 0.02);
                    }
                });
                this.hazards.forEach(hazard => {
                    if (hazard.userData.type === 'saw') Utils.animateRotate(hazard, 0, 0, 0.1);
                });
                this.environment.forEach(envObj => {
                    if (envObj.userData && (envObj.userData.type === 'tree' || envObj.userData.type === 'grass' || envObj.userData.type === 'hedge')) {
                        envObj.rotation.z = Math.sin(Date.now() * 0.001) * 0.02;
                    }
                });
            }
            getPlayerSpawnPosition() {
                if (this.levelData && this.levelData.spawn) {
                    return new THREE.Vector3(this.levelData.spawn.x || 0, this.levelData.spawn.y || 5, this.levelData.spawn.z || 0);
                }
                return new THREE.Vector3(0, 5, 0);
            }
            getLevelGoal() {
                if (this.levelData && this.levelData.goal) return this.levelData.goal;
                return { type: 'collect_all_coins' };
            }
            checkLevelComplete() {
                const goal = this.getLevelGoal();
                switch (goal.type) {
                    case 'collect_all_coins':
                        const collectedCoins = this.collectibles.filter(item => item.userData.type && item.userData.type.includes('coin') && item.userData.collected).length;
                        return collectedCoins >= this.totalCoins;
                    case 'reach_flag':
                        const flag = this.interactive.find(obj => obj.userData.type === 'flag');
                        if (flag && game.player) return Utils.distance(game.player.position, flag.position) < 3;
                        return false;
                    case 'collect_keys':
                        return game.player.keysCollected >= (goal.count || 1);
                    default:
                        return false;
                }
            }
            resetCollectibles() {
                this.collectibles.forEach(collectible => {
                    collectible.userData.collected = false;
                    collectible.visible = true;
                    collectible.position.copy(collectible.userData.originalPosition);
                });
            }
            unlockDoor() {
                const door = this.interactive.find(obj => obj.userData.type === 'door' && obj.userData.locked);
                if (door && game.player.keysCollected > 0) {
                    door.userData.locked = false;
                    door.rotation.y = Utils.degToRad(90);
                    this.unlockedDoors.push(door);
                    game.player.keysCollected--;
                    Utils.updateUI('keys', game.player.keysCollected);
                }
            }
            getPlatforms() { return this.platforms; }
            getCollectibles() { return this.collectibles; }
            getHazards() { return this.hazards; }
            getInteractive() { return this.interactive; }
            getLevelInfo() {
                return { number: this.currentLevel, totalCoins: this.totalCoins, platforms: this.platforms.length, hazards: this.hazards.length, goal: this.getLevelGoal() };
            }
        }

        // Game Class
        class Game {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.loadingManager = null;
                this.gltfLoader = null;
                this.player = null;
                this.level = null;
                this.audioListener = null;
                this.backgroundMusic = null;
                this.gameState = {
                    isPlaying: false,
                    isPaused: false,
                    isLoading: true,
                    currentLevel: 1,
                    score: 0,
                    coins: 0,
                    lives: 3,
                    assetsLoaded: 0,
                    totalAssets: 0
                };
                this.requiredAssets = [
                    'assets/models/platforms/block-grass.glb',
                    'assets/models/platforms/block-grass-large.glb',
                    'assets/models/platforms/block-grass-corner.glb',
                    'assets/models/platforms/block-grass-curve.glb',
                    'assets/models/platforms/platform.glb',
                    'assets/models/platforms/platform-ramp.glb',
                    'assets/models/platforms/block-snow-large.glb',
                    'assets/models/collectibles/coin-gold.glb',
                    'assets/models/collectibles/coin-silver.glb',
                    'assets/models/collectibles/coin-bronze.glb',
                    'assets/models/collectibles/heart.glb',
                    'assets/models/collectibles/jewel.glb',
                    'assets/models/collectibles/key.glb',
                    'assets/models/environment/tree.glb',
                    'assets/models/environment/tree-pine.glb',
                    'assets/models/environment/rocks.glb',
                    'assets/models/environment/grass.glb',
                    'assets/models/environment/flowers.glb',
                    'assets/models/environment/hedge.glb',
                    'assets/models/environment/mushrooms.glb',
                    'assets/models/interactive/crate.glb',
                    'assets/models/interactive/chest.glb',
                    'assets/models/interactive/button-round.glb',
                    'assets/models/interactive/door-rotate.glb',
                    'assets/models/interactive/lever.glb',
                    'assets/models/interactive/flag.glb',
                    'assets/models/interactive/button-square.glb',
                    'assets/models/hazards/spike-block.glb',
                    'assets/models/hazards/saw.glb',
                    'assets/models/hazards/trap-spikes.glb',
                    'assets/models/hazards/bomb.glb',
                    'assets/models/structures/fence-low-straight.glb',
                    'assets/models/structures/ladder.glb',
                    'assets/models/structures/poles.glb',
                    'assets/models/structures/platform-fortified.glb'
                ];
                this.animationId = null;
            }
            async init() {
                console.log('Initializing 3D Exploration Game...');
                try {
                    this.setupScene();
                    this.setupCamera();
                    this.setupRenderer();
                    this.setupLighting();
                    this.setupAudio();
                    this.setupLoading();
                    await this.loadAssets();
                    this.player = new Player(this.scene);
                    this.level = new Level(this.scene, this.gltfLoader);
                    this.player.setupAudio(this.audioListener);
                    this.setupInput();
                    this.setupUI();
                    await this.loadLevel(1);
                    this.startGame();
                    this.playBackgroundMusic();
                } catch (error) {
                    console.error('Failed to initialize game:', error);
                    this.showError('Failed to load game. Please refresh and try again.');
                }
            }
            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
            }
            setupCamera() {
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 10, 15);
            }
            setupRenderer() {
                this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.setClearColor(0x87CEEB);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.getElementById('gameContainer').appendChild(this.renderer.domElement);
            }
            setupLighting() {
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(50, 50, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                this.scene.add(directionalLight);
                const fillLight = new THREE.DirectionalLight(0x87CEEB, 0.3);
                fillLight.position.set(-30, 20, -30);
                this.scene.add(fillLight);
            }
            setupAudio() {
                this.audioListener = new THREE.AudioListener();
                this.camera.add(this.audioListener);
                this.backgroundMusic = new THREE.Audio(this.audioListener);
                new THREE.AudioLoader().load('assets/audio/music.mp3', (buffer) => {
                    this.backgroundMusic.setBuffer(buffer);
                    this.backgroundMusic.setLoop(true);
                    this.backgroundMusic.setVolume(0.3);
                });
            }
            playBackgroundMusic() {
                if (this.backgroundMusic && !this.backgroundMusic.isPlaying) {
                    this.backgroundMusic.play();
                }
            }
            setupLoading() {
                this.loadingManager = new THREE.LoadingManager();
                this.gltfLoader = new THREE.GLTFLoader(this.loadingManager);
                this.gameState.totalAssets = this.requiredAssets.length;
                this.loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
                    const progress = (itemsLoaded / itemsTotal) * 100;
                    Utils.updateLoadingProgress(progress);
                };
                this.loadingManager.onLoad = () => {
                    console.log('All assets loaded');
                    this.gameState.isLoading = false;
                };
                this.loadingManager.onError = (url) => console.warn(`Failed to load: ${url}`);
            }
            async loadAssets() {
                console.log(`Loading ${this.requiredAssets.length} assets...`);
                const loadPromises = this.requiredAssets.map(assetPath => {
                    return Utils.loadModel(assetPath, this.gltfLoader).catch(error => {
                        console.warn(`Asset load failed: ${assetPath}`, error);
                        return null;
                    });
                });
                await Promise.allSettled(loadPromises);
                console.log('Asset loading complete');
            }
            setupInput() {
                document.addEventListener('keydown', (event) => {
                    switch(event.code) {
                        case 'KeyR': this.restartLevel(); break;
                        case 'KeyN': this.nextLevel(); break;
                        case 'KeyP': case 'Escape': this.togglePause(); break;
                        case 'KeyM': this.toggleMusic(); break;
                    }
                });
                window.addEventListener('resize', () => this.onWindowResize());
                document.addEventListener('contextmenu', (event) => event.preventDefault());
            }
            setupUI() {
                this.updateUI();
                Utils.showGameUI();
            }
            async loadLevel(levelNumber) {
                console.log(`Loading level ${levelNumber}...`);
                try {
                    const success = await this.level.loadLevel(levelNumber);
                    if (success) {
                        this.gameState.currentLevel = levelNumber;
                        const spawnPos = this.level.getPlayerSpawnPosition();
                        this.player.reset(spawnPos);
                        this.gameState.coins = 0;
                        this.updateUI();
                        console.log(`Level ${levelNumber} loaded successfully`);
                        return true;
                    } else {
                        throw new Error(`Failed to load level ${levelNumber}`);
                    }
                } catch (error) {
                    console.error(`Error loading level ${levelNumber}:`, error);
                    this.showError(`Failed to load level ${levelNumber}`);
                    return false;
                }
            }
            startGame() {
                this.gameState.isPlaying = true;
                this.gameState.isPaused = false;
                this.animate();
                console.log('Game started!');
            }
            animate() {
                if (!this.gameState.isPlaying) return;
                this.animationId = requestAnimationFrame(() => this.animate());
                if (!this.gameState.isPaused) {
                    this.update();
                    this.render();
                }
            }
            update() {
                if (!this.player || !this.level) return;
                this.player.update(this.level.getPlatforms(), this.level.getCollectibles(), this.level.getHazards(), this.level.getInteractive());
                this.player.updateCamera(this.camera);
                this.level.update();
                if (this.level.checkLevelComplete()) this.levelComplete();
                this.updateUI();
            }
            render() {
                this.renderer.render(this.scene, this.camera);
            }
            levelComplete() {
                const nextLevel = this.gameState.currentLevel + 1;
                if (nextLevel <= 3) {
                    Utils.showMessage(
                        'Level Complete!',
                        `Great job! Ready for level ${nextLevel}?`,
                        'Next Level',
                        () => {
                            Utils.hideMessage();
                            this.loadLevel(nextLevel);
                        }
                    );
                } else {
                    Utils.showMessage(
                        'Game Complete!',
                        `Congratulations! You've completed all levels!\nFinal Score: ${this.gameState.score}`,
                        'Play Again',
                        () => {
                            Utils.hideMessage();
                            this.loadLevel(1);
                            this.gameState.score = 0;
                        }
                    );
                }
            }
            playerDied() {
                if (this.gameState.lives <= 0) {
                    Utils.showMessage(
                        'Game Over',
                        `Better luck next time!\nFinal Score: ${this.gameState.score}`,
                        'Restart',
                        () => {
                            Utils.hideMessage();
                            this.restartGame();
                        }
                    );
                } else {
                    this.restartLevel();
                }
            }
            restartLevel() {
                console.log('Restarting level...');
                const spawnPos = this.level.getPlayerSpawnPosition();
                this.player.reset(spawnPos);
                this.player.lives = this.gameState.lives;
                this.level.resetCollectibles();
                this.gameState.coins = 0;
                this.updateUI();
            }
            restartGame() {
                this.gameState.score = 0;
                this.gameState.coins = 0;
                this.gameState.lives = 3;
                this.gameState.currentLevel = 1;
                this.player.lives = 3;
                this.player.isAlive = true;
                this.loadLevel(1);
            }
            nextLevel() {
                const nextLevel = this.gameState.currentLevel + 1;
                if (nextLevel <= 3) this.loadLevel(nextLevel);
            }
            togglePause() {
                this.gameState.isPaused = !this.gameState.isPaused;
                Utils.togglePauseMenu(this.gameState.isPaused);
                console.log(this.gameState.isPaused ? 'Game paused' : 'Game resumed');
            }
            resumeGame() {
                this.gameState.isPaused = false;
                Utils.togglePauseMenu(false);
            }
            addScore(points) {
                this.gameState.score += points;
            }
            addCoin() {
                this.gameState.coins++;
            }
            unlockDoor() {
                this.level.unlockDoor();
            }
            updateUI() {
                Utils.updateUI('score', this.gameState.score);
                Utils.updateUI('lives', this.player ? this.player.lives : this.gameState.lives);
                Utils.updateUI('coins', this.gameState.coins);
                Utils.updateUI('currentLevel', this.gameState.currentLevel);
            }
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            showError(message) {
                Utils.showMessage('Error', message, 'OK', () => Utils.hideMessage());
            }
            toggleMusic() {
                if (this.backgroundMusic) {
                    if (this.backgroundMusic.isPlaying) {
                        this.backgroundMusic.pause();
                    } else {
                        this.backgroundMusic.play();
                    }
                }
            }
            destroy() {
                if (this.animationId) cancelAnimationFrame(this.animationId);
                if (this.renderer) this.renderer.dispose();
                document.removeEventListener('keydown', this.handleKeyDown);
                window.removeEventListener('resize', this.onWindowResize);
            }
        }

        // Initialize game
        const game = new Game();
        game.init();
    </script>
</body>
</html>